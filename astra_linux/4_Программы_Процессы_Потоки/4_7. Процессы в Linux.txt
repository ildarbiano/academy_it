План урока:
Общие понятия о программах, процессах и потоках выполнения
Жизненный цикл процесса
Виды межпроцессного взаимодействия
Настройка доступа к общим библиотекам
Мониторинг процессов
Утилита htop
Управление приоритетом процесса
Сигналы
Управление заданиями
Тест


================= понятия о программах, процессах и потоках выполнения ===========================================
Программа в Linux 			— это исполняемый файл, который может быть запущен в отдельном процессе.
Процесс в Linux 			— это экземпляр запущеной программы, который включает в себя: исполняемый код программы, данные и ресурсы, такие как: файловые дескрипторы, сегменты памяти и т. д. Каждый процесс имеет уникальный идентификатор процесса (PID) и может быть запущен в отдельном адресном пространстве. Процессы могут взаимодействовать друг с другом через механизмы IPC (межпроцессное взаимодействие), такие как каналы, разделяемая память и сокеты.
Поток выполнения (или просто поток)	— это единица параллельной обработки внутри процесса. Потоки могут выполняться параллельно на нескольких процессорах или ядрах, что позволяет улучшить производительность приложения. Каждый поток имеет собственный стек вызовов и параметры состояния, но разделяют данные и ресурсы с другими потоками внутри процесса.

Таким образом:
	- программа состоит из одного или нескольких процессов, каждый ... 
	- процесс может иметь один или несколько потоков выполнения, которые выполняются параллельно на разных процессорах. 
	- потоки могут взаимодействовать друг с другом через общие данные или синхронизационные механизмы, такие как мьютексы или семафоры.



================= Жизненный цикл процесса =======================================================================
Жизненный цикл процесса в Linux включает в себя несколько состояний и событий, которые происходят с процессом в течение его существования.

(Creation) 			— Создание процесса: процесс создаётся, когда пользователь запускает исполняемый файл или когда другой процесс порождает новый процесс с помощью функций fork() или exec().
(Ready) 			— Готовность процесса: процесс готов к выполнению и ожидает своей очереди на выполнение.
(Running)			— Выполнение процесса: процесс выполняется и использует CPU для обработки своих задач.
(Blocked)			— Заблокированный процесс: процесс временно останавливается из-за ожидания каких-то событий, например, ввода-вывода или сигналов от других процессов.
(Termination)			— Завершение процесса: процесс завершает свою работу после того, как выполнит все необходимые задачи либо из-за ошибки в исполнении программы. Когда процесс завершается, все его ресурсы освобождаются и возвращаются операционной системе.
Кроме того, процессы могут удалиться по другим причинам, таким как сигналы от других процессов, возникновение исключительных ситуаций и другие внешние события.
(PID)				- Каждый процесс имеет свой уникальный идентификатор, который используется для управления или мониторинга работы процесса. 
(IPC)				- Кроме того, процессы могут взаимодействовать друг с другом через механизмы межпроцессного взаимодействия "Inter-Process Communication", такие как каналы, разделяемая память и сокеты (о каждом процессе чуть ниже).
В Linux существуют также системные вызовы, которые позволяют родительскому процессу мониторить и управлять его дочерними процессами, такие как wait() и kill().



================= Виды межпроцессного взаимодействия IPC =============================================================
В Linux существует несколько видов межпроцессного взаимодействия (IPC)-(Inter-Process Communication), которые позволяют процессам коммуницировать друг с другом:
(pipes) 			— Каналы: это однонаправленные потоки данных между двумя процессами, при этом процессы должны быть запущены на одном и том же компьютере. Каналы могут использоваться для передачи данных, таких как текстовые сообщения или бинарные данные.
(named pipes)			— Именованные каналы: также известны как FIFO (First In First Out), похожи на каналы, но создаются как специальные файлы и могут быть использованы для коммуникации между процессами, даже если они работают на разных компьютерах.
(sockets)			— Сокеты: это механизм двусторонней передачи данных между процессами через IP-сети: локальную сеть или интернет. Сокеты могут использоваться для передачи текстовых и бинарных данных, а также для управления удалёнными процессами.
(shared memory)			— Разделяемая память: это механизм, позволяющий процессам разделять общую память, в которой они могут передавать данные друг другу. Это очень эффективный способ передачи больших объёмов данных между процессами.
(semaphores)			— Семафоры: это механизмы синхронизации процессов, обеспечивающие управление доступом к ресурсам. Семафоры могут использоваться для предотвращения гонок данных и других проблем, связанных с одновременным доступом к ресурсам между несколькими процессами.
(signals)			— Сигналы: это механизмы асинхронного уведомления процессов об определённых событиях. Они могут быть использованы для передачи информации о возникновении ошибок или других событий между процессами.
(message queues)		— Очереди сообщений: это механизмы для передачи сообщений между процессами с использованием очереди. Они могут быть использованы для передачи структурированной информации между процессами.
Некоторые из этих механизмов, такие как каналы и сокеты, могут быть легко использованы практически в любом языке программирования. Остальные механизмы, такие как разделяемая память и семафоры, требуют более глубокого понимания работы ОС и могут быть использованы с помощью системных вызовов, доступных в языках C и С++.
Сигналы в Linux 		— это основа для многих механизмов IPC (IPC — межпроцессное взаимодействие и управление процессами).


================= Настройка доступа к общим библиотекам ================================================================================
Для настройки доступа к общим системным библиотекам в Astra Linux можно использовать команды chmod и chown, которые позволяют изменять права доступа и владельца файлов. Первым шагом является определение пути к общим библиотекам. Обычно это каталог /usr/lib или /usr/local/lib, но в вашей системе это может быть другое место.
Затем вы можете изменить владельца и группу для этого каталога на пользователя и группу, которым нужен доступ к общим библиотекам. Это можно сделать с помощью команды chown. Например, следующая команда устанавливает владельца каталога /usr/lib в пользователя root и группу root:
sudo chown -R root:root /usr/lib

Чтобы установить права доступа к этому каталогу и его содержимому, используйте команду chmod. Например, если вы хотите дать всем пользователям полный доступ к общим библиотекам, то следующая команда установит соответствующие права:
sudo chmod -R 777 /usr/lib

Важно: давать всем пользователям полный доступ не рекомендуется в целях безопасности и предотвращения поломки системы. Лучшим решением может быть дать доступ только тем пользователям и группам, которые в этом действительно нуждаются, и только на те библитеки, которые необходимы.

ldconfig 			-для обновления кэша библиотек и добавления новых библиотек в список общих. Это может быть необходимо, если вы установили новую библиотеку в каталог общих библиотек. Чтобы использовать команду ldconfig, необходимо сначала установить пакет libc-bin. Для этого выполните следующую команду:
sudo apt install libc-bin
sudo ldconfig			- вызов команды ldconfig - это обновит кэш библиотек и добавит новые библиотеки в список общих. 
/etc/ld.so.conf.d/		- установили новую библиотеку, но она не появилась в списке общих библиотек, то возможно её надо добавить в файл. Для этого:
1.    Создайте новый файл с расширением .conf в каталоге
2.    Добавьте в него путь к вашей новой библиотеке:
/usr/local/lib
3.    Сохраните файл и вызовите команду ldconfig. Она обновит кэш библиотек и добавит новую библиотеку в список общих.
Важно: изменение прав доступа и владельца общих системных библиотек может быть опасным и может нарушить работу ОС. Поэтому перед выполнением этих команд убедитесь, что вы понимаете последствия своих действий и имеете соответствующие права доступа.



================= Мониторинг процессов TOP ===========================================================================
Мониторинг процессов в Linux может быть осуществлён различными способами. Один из наиболее популярных способов — использование утилиты top.
Чтобы использовать top, выполните следующую команду в терминале:
top		- консольная утилита top представляет собой интерактивный мониторинг процессов в Linux. Она отображает список процессов и информацию о потребляемых ими ресурсах: процессор, память, потоки ввода-вывода и другие.
top -p 1234	- отображения информации о ресурсах, используемых конкретным процессом, можно использовать команду top с параметром -p и указанием PID процесса.
Команда top в Linux	https://losst.pro/komanda-top-v-linux
Вывод top состоит из нескольких секций: верхняя и нижняя.
В верхней части экрана находится общая информация о системе, В первой строчке:
top 		— 15:45:34 up 1:54, - текущее системное время,  время «uptime» (часов:минут), 
1 user 		— количество пользователей в данный момент в системе. 
load averages отображается 3 параметра: 
0,24, 		Первый параметр показывает среднюю загрузку сервера за последнюю минуту до ввода команды top,
0.09, 		второй параметр — за 5 минут
0.07. 		третий параметр — за 15 минут.  Значения этих параметров представляют собой отношение количества процессов, находящихся в различных состояниях, к количеству процессорных ядер на сервере.  Таким образом, значение первого параметра показывает текущую загрузку CPU на минутном интервале. Значение загрузки близко к 1 означает, что на одно ядро CPU приходится почти один процесс в ожидании. Если значение превышает количество ядер CPU, то это означает, что на сервере много процессов, которые ждут своей очереди на выполнение. 

Вторая строка, показывает «Tasks»: 
total		— общее количество процессов;  
running 	— выполняющиеся в данный момент;  
sleeping 	— процесс находится в спящем режиме;  
stopeed 	— остановленные процессы;  
zombie 		— процесс, который является дочерним процессом и фактически уже не выполняется, но его родительский процесс ещё запущен и в состоянии работы. 

Третья срока, «%Cpu(s)»: 
us 		— процент времени на выполнение процессов пользователей, для которых не задан приоритет;  
sy 		— процент времени на выполнение процессов ядра, использование CPU системой; 
ni 		— процент времени на выполнение процессов с заданным приоритетом;  
id 		— «простаивающая» вычислительная мощность;  
wa 		— процент времени на выполнение операций IO (ввода/вывода), то есть дисковых операций (чем медленнее диск, тем выше будет значение для каждого процесса);  
hi 		— процент времени на обработку аппаратных прерываний (на уровне железа);  
si 		— процент времени на обработку программных прерываний (на программном уровне);  
st 		— мера загруженности гипервизора. 

Четвертая и пятая строки «Mem» и «Swap»: 
total 		— общий объём оперативной памяти;  
used		— объём используемой памяти;  
free 		— объём свободной памяти;  
buffers 	— объём буфера;  
cached 		— объём кэша операций ввода/вывода.

Колонки таблицы top:
PID 		— идентификатор процесса
USER 		— пользователь, запустивший процесс
PR 		— приоритет процесса
NI 		— "nice" значение процесса, позволяющее управлять его приоритетом
VIRT 		— общий размер виртуальной памяти, занятой процессом
RES 		— размер физической памяти (RSS) процесса
SHR 		— общий размер общих библиотек, которые использует процесс
S 		— текущий статус процесса:
	S	=sleeping, 
	R	=running, 
	Z	=zombie (Завершённый процесс ожидающий когда родитель его удалит), 
	I	=idle — «бездействующий»и т.д.)
%CPU 		— процент загрузки процессора, занимаемый им
%MEM 		— процент используемой физической памяти
TIME+ 		— время с момента запуска процесса в формате дни+часы:минуты:секунды
COMMAND 	— команда, запустившая процесс.
Если вы хотите отсортировать таблицу по определённой колонке, нажмите соответствующую клавишу. Например:
Shift+P 	— сортировка по проценту использования процессора
Shift+M 	— сортировка по использованию физической памяти
Shift+T 	— сортировка по времени запуска процесса
Если в таблице много строк, можно проскроллить список процессов вверх и вниз, используя стрелки клавиатуры.
top позволяет отображать информацию только о конкретном процессе.  Для этого нажмите клавишу O, затем введите имя пользователя или PID процесса. Когда имя или PID выбраны, нажмите клавишу Enter, и top будет отображать информацию только о выбранном процессе.
O		добавить фильтр
q		Для выхода из top
r		изменить приоритет процесса.  Введите PID процесса и новый приоритет,  затем нажмите клавишу Enter.
--------------------------------------------------



cd /proc
ls
cat /proc/{NUMBER PROC}/{NAME}


================= Утилита HTOP ===================================================================================
Другой инструмент для мониторинга процессов — утилита htop. Она представляет собой улучшенную версию top с дополнительной функциональностью и более удобным интерфейсом. Чтобы использовать htop, выполните следующую команду в терминале: 
sudo apt-get install htop			Начнётся скачивание и установка. После установки вы можете запустить htop, выполнив следующую команду: 
htop

Кроме того, вы можете использовать команду ps, чтобы получить список всех процессов, выполняющихся в системе: 
ps	- выведет список всех процессов в системе, использующих ресурсы процессора, памяти, а также информацию о запуске и завершении процессов.
ps aux	- где:
	a	- процессы на всех терминалах
	u	- users
	x	- все процессы
ps aux | grep 
ps ax -eo "%p:%c" | grep [m]c
ps ax -eo "" | grep "" " | cut -d ";" --fields=1
ps -p 1234	- отображения информации о процессе с PID 1234. 
top -p 1234	- отображения информации о ресурсах, используемых конкретным процессом, можно использовать команду top с параметром -p и указанием PID процесса.

Настоятельно рекомендуется использовать утилиты мониторинга процессов с ограниченными правами пользователя, чтобы избежать возможных проблем с безопасностью и непреднамеренным повреждением системы.



================= Управление приоритетом процесса ================================================================
Управление приоритетом процессов в Linux может помочь улучшить производительность системы, распределяя ресурсы процессора и памяти между процессами. В Linux существует несколько способов изменения приоритета процессов.
nice
Один из способов — использование утилиты nice.  Команда nice позволяет запускать процесс с заданным приоритетом.  Приоритеты находятся в диапазоне от -20 до 19, где -20 — наивысший приоритет, 19 — наименьший приоритет.  Чтобы запустить процесс с определённым приоритетом, выполните команду в следующем формате:
nice -n priority command	Где:
	priority 		— приоритет, назначаемый процессу,  а command — команда, которую необходимо запустить.
nice -n 10 bash
renice
Другой способ изменения приоритета процесса — использование команды renice.  Эта команда позволяет изменять приоритеты уже запущенных процессов.  Чтобы изменить приоритет процесса, выполните команду в следующем формате:
renice priority PID 		Где:
	priority 		— новый приоритет процесса,  а PID — идентификатор процесса.
renice -n -20 -p 1111
top
Кроме того, можно использовать утилиту top, обсуждаемую ранее, чтобы изменять приоритеты процессов.  Для этого введите top в терминале,  затем нажмите клавишу 
r				- клавишу, чтобы изменить приоритет процесса.  Введите PID процесса и новый приоритет,  затем нажмите клавишу Enter.
/etc/security/limits.conf
Наконец, можно использовать файл /etc/security/limits.conf, чтобы назначить определённым пользователям или группам конкретные значения приоритетов. В этом файле можно указать различные лимиты, такие как максимальное количество процессов или открытых файлов, а также приоритеты процессов для каждого пользователя или группы.  Для этого необходимо добавить соответствующие строки в файл /etc/security/limits.conf. Например:
@audio - nice -19
@users soft priority 10
Эти строки устанавливают наивысший приоритет для группы audio и приоритет 10 для всех пользователей.
Изменение приоритетов процессов может повлиять на производительность системы и другие процессы. Вы должны быть осторожны при изменении приоритета процессов для избежания возможных проблем.



================= Сигналы ========================================================================================
Сигналы в Linux 	— это основа для многих механизмов IPC (IPC — межпроцессное взаимодействие и управление процессами).
Сигналы в Linux 	— это механизм для уведомления процессов о событиях, таких как завершение работы или получение сигнала от другого процесса. Сигналы используются в различных ситуациях, например, при завершении процесса по инициативе ОС, при остановке процесса пользователем или при получении сообщения от другого процесса. Каждый сигнал имеет свой уникальный номер и может быть отправлен в процесс с помощью функции kill().
kill -l			- перечень возможных сигналов, которые можно передать процессу.
kill -9 {command}
kill -9 PID		- SIGKILL, немедленная остановка процесса программы.
kill 			- используется для завершения процесса. Эта команда принимает в качестве аргумента номер PID (идентификатор процесса), который можно узнать с помощью команды ps.
man kill		- детальное описание сигналов
Процесс также может сам отправлять сигналы другим процессам. При получении сигнала процесс может обработать его с помощью зарегистрированного обработчика сигналов. Если обработчик не зарегистрирован для данного сигнала, то процесс может выполнить стандартное действие по умолчанию (например, завершить работу). Если процесс заблокировал получение сигнала, то при поступлении сигнал не будет получен до снятия блокировки. Блокировка сигналов может быть использована, например, для избегания прерывания выполнения критически важных операций. 
Наиболее часто используемые сигналы в Linux:  
SIGTERM 	— 15 	- для остановки процесса,  
SIGKILL 	— 9 	- для принудительного завершения процесса,  
SIGINT 		— 2  	- для остановки процесса по нажатию сочетания клавиш Ctrl+C.  
Механизм сигналов довольно гибок и мощен, но также требует аккуратного использования для предотвращения нежелательных побочных эффектов. Например, неправильное использование сигналов может привести к утечке ресурсов, неопределённому поведению процессов и к другим проблемам. Необходимо отметить, что в задачи специалистов SD и админов не входят задачи определения логики обработки сигналов для программ, утилит и т. д. — это задачи программиста. Они заключаются в том, чтобы правильно определить логику обработки сигналов для своих программ и минимизировать возможные ошибки и сбои в работе. Кроме того, механизм сигналов может быть использован для реализации других асинхронных операций, таких как обработка сетевых сообщений и выполнение операций с файлами.
Понимание механизма сигналов является важным аспектом разработки программ для Linux. Оно позволяет программистам создавать более эффективные и надёжные программы, которые успешно функционируют в Linux-среде.



================= Управление заданиями ===========================================================================
Управление заданиями в Linux является важным аспектом работы в операционной системе и включает в себя планирование заданий на выполнение, запуск заданий, управление запущенными заданиями и многое другое. Один из инструментов планирования задач в Linux — это cron.
Cron 			- позволяет планировать выполнение задач в указанные моменты времени или по расписанию. Для этого необходимо: 
crontab -e.		- cоздать файл crontab, который содержит список задач и расписание их выполнения. В файле crontab каждая строка соответствует одной задаче и имеет следующий формат:
* * * * * {command}	- первые пять символов определяют расписание выполнения задачи. Каждый символ соответствует минуте, часу, дню месяца, месяцу и дню недели соответственно. Звёздочка означает использование всех возможных значений данного параметра. 
* * * *			- означает выполнение задачи каждую минуту круглые сутки.
После пяти символов расписания идёт команда, которую нужно выполнить. Команда должна быть полностью определена, включая путь к исполняемому файлу.
crontab -l		- посмотреть, что есть в текущем расписании
crontab -e 		- если хотим что-то в расписании поменять, то запускаем команду. Синтаксис расписания cron:
{минута}{час}{день}{месяц}{день_недели}{путь_к_скрипту_или_непосредственно_команда}
10 3 * * * /home/admuser/my.sh		- запуск shell-скрипта каждый день в 3:10 утра
*/1 7-19 * * 1 /home/admuser/my.sh	- запуск каждую минуту понедельника с 7 до 19  (понедельник — это первый день, а воскресенье — седьмой или нулевой).
/etc/cron.allow				- в файле /etc/cron.allow можно указать список пользователей, у которых будет доступ к cron, или в файле /etc/cron.deny 				- указать пользователей, которым доступ запрещён. 
Одновременно можно использовать только один из списков. Также обратите внимание, что имена записываются по одному на каждой строчке. 
/etc/crontab				- туда тоже иногда записывают расписания.
Кроме crontab, в Linux существует множество других программ для управления заданиями, включая аналоги: anacron и fcron. Есть также интерактивные планировщики задач: GNOME Schedule и KAlarm, которые предоставляют более удобный интерфейс для планирования задач.









