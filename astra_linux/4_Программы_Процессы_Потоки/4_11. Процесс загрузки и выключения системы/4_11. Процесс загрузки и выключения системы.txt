План урока:

Порядок и стадии начальной загрузки
Работа с BIOS и EFI
Настройка загрузчика GRUB2
Загрузка ядра ОС
Управление модулями ядра
Управление службами через systemd
Управление целевыми состояниями системы через systemd
Создание собственных юнитов systemd
Практическое задание


==================== Порядок и стадии начальной загрузки ==============================================
При загрузке операционной системы Astra Linux происходит несколько этапов:
1. BIOS/UEFI 
- Первичная инициализация аппаратных компонентов, например, проверка и установка системных часов, определение жестких дисков, проверка наличия оперативной памяти и других аппаратных средств. Если найдены ошибки, компьютер может выдавать соответствующие сообщения или сообщения об ошибках.
2. Bootloader 
- Компьютер производит передачу управления загрузчику GRUB, который инициализирует загрузку системы. Из меню управления загрузчика можно выбрать операционную систему, соответствующую определенному дистрибутиву Astra Linux.
3. Kernel 
- Загружается ядро операционной системы Linux, которое определяет аппаратные конфигурации, файловые системы, маршрутизацию и управление устройствами ввода/вывода и другие настройки. После загрузки ядра происходит инициализация основных компонентов и драйверов системы.
4. Init  
- Система Astra Linux запускает сервисы, указанные в файле /etc/inittab или /etc/init.d и скрипты, которые автоматически запускаются при загрузке. Эти сервисы могут включать сетевые службы, демоны, процессы и другие приложения.
5. Runlevel 
- Система Astra Linux переходит в определённый режим работы, который определяется текущим уровнем запуска (runlevel). 
Astra Linux по умолчанию используется 5 уровней запуска:
N 	- уровень запуска по умолчанию, который определяет работу в многофункциональном режиме, сочетающем консольный и графический доступ.
0 	- выключение операционной системы.
1 	- однопользовательский режим, предоставляющий консольный доступ без сетевых сервисов.
2 	- многофункциональный режим, но без графического доступа.
6 	- перезагрузка операционной системы.
На каждом уровне запуска определенный набор сервисов запускается автоматически, что позволяет оптимизировать работу системы в зависимости от ее конфигурации и потребностей пользователя.
6. Services  
- Система Astra Linux активирует и продолжает работу запущенных сервисов. Сервисы продолжают работать в фоновом режиме, выполняя задачи, которые были назначены им на стадии инициализации и запуска. Они могут выполнять различные задачи, от отслеживания сетевых подключений до выполнения процессов бэкапа. Сервисы в системе Astra Linux могут быть запущены автоматически во время начальной загрузки, а также могут быть запущены и управляемы пользователем вручную. Управление сервисами осуществляется через специальный инструмент systemctl, который может использоваться для активации, деактивации, перезапуска и многих других операций со службами.

Службы, которые могут быть запущены на этапе завершения начальной загрузки  в Astra Linux, включают:
NetworkManager 	- сервис сетевого управления, который обеспечивает управления подключениями к местным Ethernet и WLAN сетям и соединениям VPN;
SSH 		- сервис, который обеспечивает удаленный доступ к системе Astra Linux по SSH-протоколу;
Apache 		- веб-сервер, который обеспечивает доступ к веб-сайтам и приложениям; 
Postfix 	- почтовый сервис, который обеспечивает отправку и получение электронной почты.
Каждый из этих сервисов может быть настроен для выполнения многих различных задач и для обеспечения оптимальной работы системы Astra Linux.  Например, сервис NetworkManager может быть настроен для работы с различными типами сетей, а сервис Apache может быть настроен для поддержки различных веб-интерфейсов. В целом, на этапе Services происходит активация сервисов, которые работают в операционной системе Astra Linux, чтобы обеспечить ее работу в фоновом режиме. Работа этих сервисов может быть настроена для выполнения множества различных задач, в зависимости от требований пользователя и конфигурации системы.



==================== Работа с BIOS и EFI ==============================================================
При первоначальной загрузке операционной системы Astra Linux различные этапы загрузки могут немного отличаться в зависимости от типа системы 
BIOS		(Basic Input/Output System)
EFI 		(Extensible Firmware Interface).
Основное различие между первоначальной загрузкой Astra Linux на системах BIOS и EFI заключается в том, что система EFI использует свой собственный загрузчик - EFI bootloader, который может работать с более новыми и уникальными системами, а также поддерживает различные файловые системы, такие как FAT/NTFS. Для использования EFI bootloader пользователь будет взаимодействовать с менеджером загрузки, в котором нужно выбрать загрузочный заголовок, и данный менеджер можно настроить в соответствии со специфичными требованиями конфигурации EFI машины.

BIOS 
- были стандартом в компьютерах уже длительное время и служат для основных функций системной платы и компьютера в целом. В случае Astra Linux, при использовании BIOS первоначальный загрузчик (bootloader) будет храниться на первом секторе жесткого диска в MBR (Master Boot Record), а затем система начнет загрузку ядра ОС.

EFI 
- используется другой тип загрузчика - EFI bootloader. EFI Bootloader объединяет информацию об разных частях операционной системы, включая ядро ОС, и дает понимание файловой системе для извлечения необходимых файлов. EFI Bootloader предназначен для использования с различными типами файловых систем, таких как FAT/NTFS, и позволяет загружать более новые и уникальные системы, которые не могут работать с BIOS. При первоначальной загрузке Astra Linux на EFI дисплее на экране появится менеджер загрузки. В менеджере загрузки пользователь может выбрать загрузочный заголовок (boot section), который может быть разделом всех доступных жестких дисков. Меню выбора может быть настроено или изменено через файлы конфигурации bootloader. Это необходимо, если установка Astra Linux должна быть настроена на работу с конкретной конфигурацией EFI машины.



==================== Настройка загрузчика GRUB2 =======================================================
Настройка GRUB2 позволяет пользователям изменять параметры загрузки операционных систем, которые установлены на компьютере, а также улучшать внешний вид и настраивать таймер отсчёта перед загрузкой.
GRUB2 			— это загрузчик операционных систем Linux и Astra Linux. Он заменяет старый загрузчик GRUB и позволяет пользователю выбрать из списка операционных систем, которые установлены на компьютере. Настройка GRUB2 может быть осуществлена на различных уровнях, например, для добавления новой операционной системы в меню загрузки или для изменения таймера отсчета, прежде чем GRUB2 выберет операционную систему по умолчанию. Основная конфигурация GRUB2 хранится в файле grub.cfg. В нём содержится информация о том, какие операционные системы отображаются в меню GRUB2 и в каком порядке они отображаются. Пользователи могут изменять этот файл, чтобы добавить новые операционные системы или изменить порядок, в котором они отображаются. Пользователи также могут настроить GRUB2, чтобы изменить таймер отсчета, прежде чем загрузчик выберет операционную систему по умолчанию. Это может быть полезно для тех, кто хочет временно выбрать другую операционную систему для загрузки, но продолжать возвращаться к операционной системе по умолчанию в большинстве случаев. 
/etc/default/grub 	- для настройки GRUB2, пользователям нужно отредактировать конфигурационный файл и сохранить изменения. Некоторые из параметров, которые можно изменить, включают в себя таймер отсчета, действия, выполняемые перед загрузкой операционной системы по умолчанию, режимы консоли вывода и другие. После сохранения изменений в конфигурационном файле /etc/default/grub, пользователь должен запустить команду update-grub. Это обновляет файл grub.cfg и применяет настройки, внесенные в файл /etc/default/grub.
			- другой способ настройки GRUB2 состоит в добавлении новой операционной системы в меню загрузки.
Для этого пользователю необходимо создать новую запись в файле /etc/grub.d/40_custom и указать параметры загрузки для этой операционной системы, например расположение ядра, параметры ядра и т. д. После создания новой записи и сохранения изменений пользователь должен выполнить команду update-grub, чтобы обновить файл grub.cfg и добавить новую операционную систему в меню загрузки. Кроме того, пользователи могут изменить внешний вид GRUB2, например, размер шрифта, цвета, фон путём настройки файла /etc/grub.d/00_header. При этом, как и в предыдущих случаях, после сохранения изменений команду update-grub нужно выполнить для применения настроек. 



==================== Загрузка ядра ОС =================================================================
При загрузке ядра Astra Linux могут быть переданы различные параметры. Эти параметры указывают, как загрузчик должен настроить ядро, какие модули должны быть загружены, как настроены устройства и многое другое.
Самые распространённые параметры загрузки ядра Astra Linux:
root			= указывает, в каком разделе должна быть найдена корневая файловая система.
quiet			= отключает вывод сообщений ядра, чтобы ускорить загрузку.
splash			= показывает экран загрузки с логотипом.
initrd			= указывает, какой файл должен быть загружен в качестве временной файловой системы в RAM перед тем, как загрузить настоящую корневую файловую систему.  Это может быть полезно при настройке RAID-массивов или шифрования дисков.
Некоторые из этих параметров могут быть зависимыми от конкретного оборудования или настроек, поэтому перед добавлением параметра в командную строку загрузки ядра Astra Linux убедитесь, что вы понимаете его значение и последствия.
В файле 
/etc/default/grub	= можно настроить параметры загрузки ядра Astra Linux. Внесите изменения в этот файл и выполните команду update-grub для обновления файла конфигурации grub.cfg. Пример файла /etc/default/grub на Astra Linux:
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="parsec.max_ilev=63 quiet net.ifnames=0"
GRUB_CMDLINE_LINUX=""
GRUB_CMDLINE_LINUX_HARDENED="slub_debug=P page_poison=1 slab_nomerge pti=on user.max_user_namespaces=0 kernel.kptr_restrict=1 vsyscall=none"
GRUB_GFXMODE=1024x768
GRUB_DISABLE_SUBMENU=y
GRUB_DEFAULT=gnulinux-5.4.0-54-generic-advanced-6e9da07e-b33a-4af8-9638-71714dae2913
Параметры загрузки могут быть использованы для настройки различных функций ядра:
acpi=off acpi=force 	= Управляют функциями ACPI (Advanced Configuration and Power Interface) и могут быть использованы для устранения проблем, таких как неправильное управление электропитанием или проблемы с горячей заменой.  acpi=off полностью отключает ACPI,  а acpi=force принудительно включает его в случае, если он не был обнаружен автоматически.
pci=noacpi pci=acpi 	= Управляют электропитанием для шины PCI и могут быть использованы для устранения проблем с некоторыми устройствами PCI.
noapic nolapic		= Позволяют отключить функции APIC (Advanced Programmable Interrupt Controller) и могут быть использованы для устранения проблем с перераспределением или обработкой прерываний.
nomodeset		= Отключает поддержку режимов дисплея и использовать стандартное разрешение экрана. Этот параметр может быть полезен при проблемах с графикой.
vga=xxx			= Задаёт разрешение экрана и количество цветов, если драйвер графической карты не обнаружен автоматически.
Параметры загрузки ядра Astra Linux могут быть полезными при настройке конфигурации системы. Однако, прежде чем использовать параметры загрузки ядра Astra Linux, необходимо понимать их значение и последствия. Также следует убедиться, что параметры учитывают конфигурацию системы и требования пользователя.



==================== Управление модулями ядра =============================================================================================
При загрузке ядра операционная система загружает основной модуль ядра и определённый набор модулей для обеспечения поддержи аппаратуры и функциональности, это прослойка между ядром.
Модули 			— это динамически подключаемые файлы, которые могут быть загружены и выгружены по требованию. Это означает, что модули начинают работать только тогда, когда они действительно нужны для работы компьютера.
rmmod			- команда ручной выгрузки модулей;
modprobe		- команда ручной закгрузки модулей.
/etc/modules		- список автоматически загружаемых модулей, добавив их в список в файле. Здесь вы можете перечислить имена модулей, которые операционная система должна загружать при старте.
/etc/modprobe.d/	- настраивать модули ядра через конфигурационный файл, например, чтобы загрузить модуль с определенными параметрами.
lsmod			- команда для просмотра списка текущих загруженных модулей.
modinfo			- команда позволяет получить информацию о конкретном модуле ядра.

	


==================== Управление службами через systemd ===================================================================================
systemd 			— это способ управлять системными службами, системный инициализатор и менеджер служб в Linux. Он заменяет более старые системные инициализаторы, такие как init и upstart. В systemd службы являются центральными объектами, которыми управляются все аспекты системы.
systemd				- менеджер служб, позволяет проводить дополнительную настройку.
systemd 			- позволяет проводить журналирование своей работы, а именно просматривать лог-файлы через команду journalctl.  
Unit				- представление cистемных служб в systemd. Системные службы представлены в systemd, как юниты Units.
/etc/systemd/system/ 		- Файлы юнитов Units
/usr/lib/systemd/system/	- Файлы юнитов Units
Unit				- представлен отдельным файлом, где в качестве имени указывается название службы и расширение файла service. Юниты могут быть службами, таймерами, монтированиями, устройствами. изменить файл юнита в соответствии с вашими требованиями, чтобы запускать приложения с определёнными параметрами. Также можно определить зависимости между службами, чтобы они запускались друг за другом или останавливались в обратном порядке.
journalctl			- лог-файл журналировнания systemd. Управление процессами systemd происходит с помощью systemctl.
systemd 			- предоставляет ряд дополнительных возможностей:
systemctl isolate graphical.target	- переводит систему в режим графического режима. 
.target					- возможность работать со службами в группах. 
Управление cgroups 			- механизмами контроля доступа к ресурсам, таким как память, процессорное время и дисковое пространство.
systemd-run				- встроенный механизм для организации и контроля процессов задания.
systemd 			— это мощный менеджер служб, который не только упрощает управление службами операционной системы, но и предоставляет множество дополнительных возможностей для настройки и управления системой.



==================== Управление целевыми состояниями системы через systemD ==================================================================
target				- один из способов управления системой в systemd, использование целевых состояний.
Целевое состояние 		— это группа юнитов Units, которые выполняют определённую задачу. 
multi-user.target		- (целевое состояние) является целевым состоянием по умолчанию для большинства серверов и предназначено для запуска в несколько пользователей режиме без графической оболочки. Для управления целевым состоянием вы можете использовать следующие команды:
				- см. вложенный файл "команды управления целевым состоянием"
Можно создавать свои собственные целевые состояния, которые будут отражать свои потребности, назвав файл как имя целевого состояния и указав в качестве типа target.  В этом файле можно определить список юнитов, которые должны быть запущены при переключении на данное целевое состояние.
/etc/systemd/system/ 		- для этого создайте новый файл юнита Unit;
/usr/lib/systemd/system/	- для этого создайте новый файл юнита Unit. Разницы для systemctl между директориями /etc/systemd/system/ и /usr/lib/systemd/system/ нет.  
/etc/systemd/system/ 		- обычно в директорию записываются пользовательские сервисы, а 
/usr/lib/systemd/system/	- обычно используется по умолчанию для любого устанавливаемого ПО.       
Использование целевых состояний позволяет упростить и автоматизировать процесс управления системой. Целевые состояния могут быть настроены на конкретную задачу, например запуск служб базы данных или выполнение сетевых функций. Кроме того, вы можете создавать собственные целевые состояния, а также добавлять и удалять юниты в целевые состояния.
Система systemd расширяет функциональность управления целевыми состояниями следующими командами:
				- см. вложенный файл "команды управления целевым состоянием"
Использование целевых состояний systemd делает управление системой более гибким, быстрым и простым.

[Unit]				- блок. Что должно быть прописано в блоке [Unit] юнит-файла для сервиса Apache?
Description=	- Краткое описание юнита, общие параметры, которые не зависят от типа юнита.
Documentation= 	— список URI, ссылающихся на документацию для юнита
Documentation=man:sshd(8) man:sshd_config(5)
Параметры - дополнительные директивы:
After= 		— указывает, после каких демонов и событий нужно запускать юнит. Например, модули веб-серверов запускаются только после сетевых интерфейсов.
Requires= 	— сервисы, необходимые для работы юнита. Если текущий юнит запускается, то и все юниты из этой директивы также будут запущены.
Wants= 		— сервисы, которые желательно запустить перед стартом юнита.
PartOf=		— зависимости, которые срабатывают только при остановке и перезапуске: когда systemd останавливает или перезапускает юнит в PartOf, то и текущий юнит будет остановлен или перезапущен.

[Service]			- блок, указывают, как и когда сервис должен быть запущен, остановлен, перезагружен и так далее. Эта секция содержит информацию, специфичную для описания сервиса, и определяет его поведение.
ExecStart= 			— путь к демону и аргументы демона для его запуска. При указании минуса перед строкой команды systemd не будет запоминать код завершения процесса. 
Type= 				— определяет, каким образом systemd будет отслеживать, запустился ли сервис. Например:
	simple (по умолчанию) 	— служба запускается незамедлительно, процесс не должен разветвляться; 
	forking 		— служба запускается однократно, процесс разветвляется с завершением родительского процесса (используется для запуска классических демонов).
User=				— пользователь, под которым нужно стартовать сервис. 
Group=				— группа, под которым нужно стартовать сервис. 
PIDFile=			— если тип службы отмечен как forking, устанавливает путь файла, который должен содержать идентификационный номер процесса основного «ребёнка». 
WorkingDirectory=		— рабочий каталог службы, он делается текущим перед запуском стартап-команд. 
Environment=			— задаёт переменные окружения, которые должны быть доступны службе. 
ExecStop=			— задают команды stopсервиса. Важно указывать полный путь — systemd настаивает на этом. 
ExecReload=			— задают команды на reload сервиса. Важно указывать полный путь — systemd настаивает на этом. 
Restart=			— предписывает перезапускать сервис, если он перестанет работать. 
RestartSec=			— если автоматический перезапуск службы включён, указывает время ожидания перед попыткой перезапуска.



==================== Создание собственных юнитов systemd ====================================================================================
-------------------- ПРИМЕР 1 юнит для сервиса Apache с описанием Apache Web Server ---------------------------------------------------------
Рассмотрим пример использования юнита для запуска сервиса Apache. Для этого нужно создать юнит-файл /etc/systemd/system/apache.service со следующим содержимым:
--------
[Unit]
Description=Apache Web Server
After=network.target
[Service]
Type=simple
ExecStart=/usr/sbin/httpd -DFOREGROUND
[Install]			
WantedBy=multi-user.target
-------------------------------------
[Unit]  			- блок	
Description=Apache Web Server	- краткое описание юнита.
Documentation 			— список URI, ссылающихся на документацию для юнита
After=network.target		- зависимость от network.target. Юнит должен быть запущен после завершения загрузки сетевых интерфейсов 
[Service]			- блок
Type=simple			- в блоке  определяется тип запуска сервиса (simple) и 
/usr/sbin/httpd -DFOREGROUND	- команда для запуска сервиса. 
[Install]			- блок
WantedBy=multi-user.target	- мы указали, что юнит должен быть запущен при загрузке системы в многопользовательском режиме.
Важно! 
systemctl daemon-reload		- если юнит создавался впервые, то необходимо выполнить команду. Команда systemctl daemon-reload используется для перезагрузки конфигурации systemd, после внесения изменений в юнит-файлы или другие настройки. Когда происходят изменения в конфигурации systemd, это может привести к несовместимости со старой версией конфигурации, поэтому systemctl daemon-reload необходимо вызывать после внесения любых изменений в конфигурацию. Эта команда сигнализирует демону systemd, чтобы он перезагрузил свою конфигурацию и обновил данные о доступных юнитах и их настройках. В общем, systemctl daemon-reload нужно вызывать после внесения изменений в юнит-файлы, прежде чем вы сможете использовать или взаимодействовать с сервисами или другими ресурсами, управляемыми systemd.
systemctl start apache.service	- чтобы запустить сервис Apache;
systemctl stop apache.service	- чтобы остановить сервис.
systemctl enable apache.service	- чтобы настроить автозапуск сервиса при загрузке системы.

--------------------- ПРИМЕР 2 монтирование файловой системы -----------------------------------------------------------------------------------------
Еще один пример использования юнитов - это монтирование файловой системы (более подробно о монтировании удалённых ресурсов мы рассмотрим в теме «Расширенное управление устройствами»). Допустим, у вас есть сетевой диск, который вы хотите монтировать при загрузке системы. Для этого создайте юнит-файл /etc/systemd/system/network-drive.mount со следующим содержимым:
------
[Unit]
Description=Network Drive Mount
Before=local-fs.target
Wants=network-online.target
After=network-online.target
[Mount]
What=//server/share
Where=/mnt/network
Type=nfs
Options=username=user,password=pass
[Install]
WantedBy=multi-user.target
---------------------------
[Unit] 					- блок
Description=Network Drive Mount		- определили юнит для монтирования сетевого диска с описанием. 
Before=local-fs.target			- Юнит должен быть запущен до монтирования локальных файловых систем (зависимость от local-fs.target).
Wants=network-online.target		-
After=network-online.target		- чтобы гарантировать, что сеть была доступна перед монтированием, мы указали зависимость от network-online.target.
[Mount]
What=//server/share			- указываем, что монтируем (//server/share)
Where=/mnt/network			- указываем, куда (/mnt/network)
Type=nfs				- тип монтирования (cifs)
Options=username=user,password=pass	- опции монтирования (username=user,password=pass)
[Install]
WantedBy=multi-user.target		- указали, что юнит должен быть запущен при загрузке системы в многопользовательском режиме (WantedBy=multi-user.target).
systemctl start network-drive.mount	- Чтобы монтировать сетевой диск, запустим юнит командой. 
systemctl stop network-drive.mount.	- Чтобы размонтировать диск.
systemctl enable network-drive.mount	- Чтобы настроить автоматическое монтирование при загрузке системы, выполните команду. 
Теперь сетевой диск будет монтироваться при каждой загрузке системы.

--------------------- ПРИМЕР 3 создать целевое состояние для запуска различных сервисов, связанных с базами данных ===========================================
Допустим, вы хотите создать целевое состояние для запуска различных сервисов, связанных с базами данных. Для этого можно создать новый файл юнита в директории /etc/systemd/system/ или /usr/lib/systemd/system/, назвав его my-db.target. Затем можно определить список юнитов, которые должны быть запущены, когда переключается система на данное целевое состояние. Например, создадим файл /etc/systemd/system/my-db.target со следующим содержимым. В этом примере мы создали целевое состояние с названием my-db.target, которое зависит от служб MySQL и PostgreSQL.:
------
[Unit]
Description=My DB Services
[Install]
WantedBy=multi-user.target
[Target]
Description=My DB Services
Requires=mysql.service postgresql.service
-----------------------------------------
systemctl isolate my-db.target			- Чтобы использовать это целевое состояние. Кроме того, можно создать целевые состояния для выполнения определенных задач. Например, для запуска сервисов виртуализации необходимо:
/etc/systemd/system/virtualization.target 	- Создать файл для запуска сервисов виртуализации со следующим содержимым:
-----
[Unit]
Description=Virtualization Services
[Install]
WantedBy=multi-user.target
[Target]
Description=Virtualization Services
Requires=qemu-kvm.service libvirtd.service
------------------------------------------
systemctl isolate virtualization.target		- команда, чтобы переключить систему в целевое состояние для запуска служб виртуализации.

--------------------- ПРИМЕР 4 использование таймеров ------------------------------------------------------------------------------------------------------
Таймеры в systemd используется для задания отложенного запуска сервиса, например, для резервного копирования базы данных ежедневно в определенное время. Для этого создайте юнит-файл /etc/systemd/system/db-backup.timer со следующим содержимым:
------
[Unit]
Description=Database Backup Timer
[Timer]
OnCalendar=*-*-* 22:00:00
Persistent=true
[Install]
WantedBy=timers.target
----------------------
[Unit]
Description=Database Backup Timer	- определили юнит-файл db-backup.timer 
[Timer]					- блок
OnCalendar=*-*-* 22:00:00		- для запуска таймера резервного копирования базы данных каждый день в 22:00.
Persistent=true				- Опция Persistent=true гарантирует, что таймер будет запущен даже в том случае, если он был пропущен во время отключения системы.
[Install]				- блок
WantedBy=timers.target			- указали, что юнит должен быть запущен при загрузке системы в таймер-режиме (WantedBy=timers.target).
systemctl start db-backup.timer		- Чтобы запустить таймер, выполните команду
systemctl status db-backup.timer	- Чтобы проверить статус таймера, используйте команду
systemctl enable db-backup.timer	- Чтобы настроить автозапуск таймера при загрузке системы, выполните команду 