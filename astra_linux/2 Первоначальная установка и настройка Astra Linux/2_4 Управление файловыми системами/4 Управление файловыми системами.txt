https://dion.vc/video/35c3b7fb-ab69-45f7-8182-4972da0ac0cb

======= Архитектура подсистемы хранения данных ===============================
Подсистема хранения данных в Linux состоит из нескольких компонентов, каждый из которых выполняет свою специфическую функцию.   Основные компоненты подсистемы хранения данных в Linux включают:
1. Файловые системы 
Программное обеспечение, которое управляет организацией и хранением файлов на диске. Файловые системы могут быть различными, например, ext4, NTFS, FAT32 и т.д.
2. Драйверы устройств
Программное обеспечение, которое управляет обменом данными между ядром Linux и физическими устройствами хранения данных, такими как жесткие диски, флэш-накопители и CD / DVD-диски.
3. Утилиты командной строки
Программное обеспечение, которое предоставляет пользователю возможность управлять файловой системой и хранением данных на диске с помощью командной строки.
4. Графические интерфейсы
Программное обеспечение, которое предоставляет пользователю графический интерфейс для управления файловой системой и хранением данных на диске.
5. Системные вызовы
Программное обеспечение, которое предоставляет приложениям доступ к файловой системе и хранению данных на диске. Файловые системы предназначены для организации хранения данных. В Linux существует несколько типов файловых систем, таких как EXT, XFS, Btrfs и другие. Каждая файловая система имеет свои особенности и подходит для различных задач.
	Таким образом, система ввода-вывода (I/O) обеспечивает передачу данных между устройствами и операционной системой. В Linux используется блочная система ввода-вывода, которая организует передачу данных в блоках фиксированного размера. Также в Linux используется система кэширования, которая повышает производительность системы за счет ускорения доступа к файлам и блокам данных.

========= Именование файлов дисковых устройств ==============================
В Linux файлы дисковых устройств обычно именуются в соответствии с соглашением об именовании устройств. Это соглашение определяет, как имена файлов дисковых устройств будут выглядеть и как они будут связаны с физическими устройствами.
В Linux дисковые устройства именуются в соответствии с шаблоном 
/dev/<тип_устройства><номер_устройства>. 
Например, жесткий диск может быть именован как /dev/sda, где "s" означает SCSI, а "a" - первый жесткий диск.
Если в системе имеется несколько жестких дисков, то они могут быть именованы как:
/dev/sda, 
/dev/sdb, 
/dev/sdc и т.д.
Флэш-накопители могут быть именованы как:
/dev/sdb, 
/dev/sdc и т.д.
CD / DVD-диски могут быть именованы как:
/dev/cdrom или 
/dev/dvd.
Устройства USB могут быть именованы как:
/dev/sdb, 
/dev/sdc и т.д.
Имена файлов дисковых устройств могут отличаться в зависимости от дистрибутива Linux и конфигурации системы

============ Устройства ============================================================
	sudo mount /dev/sr0 /media/cdrom0
	cat /etc/ntab
	sudo umount /media/cdrom0
	ls /dev

============ Теория ================================================================
Четыре раздела на диске, максимум:
1	.
2	.
3	.
4	Extended-Расширенный
	LVM-драйвер, для управления LV, без форматирования, на "горячую"


============ File System ============================================================
Программное обеспечение, которое управляет организацией и хранением файлов на диске. Файловые системы могут быть различными, например, ext4, NTFS, FAT32 и т.д.
Список файловых систем, которые поддерживаются ядром Linux, находится в файле
cat /proc/filesystems
EXT - расшифровывается как Extended File System, расширенная файловая система. Семейство ext включает в себя несколько версий, таких как:
ext2, 
ext3 и 
ext4. 
Эти файловые системы традиционно используются в Linux. Ext3 и ext4 обратно совместимы с ext2. Важно! Размер ext4 может быть как увеличен, так и уменьшен. Это важная информация пригодится в работе с parted и LVM
Ext2 
- первая версия файловой системы ext, которая была выпущена в 1993 году. Она поддерживает файлы размером до 2 ТБ и объем раздела до 32 ТБ. Ext2 не имеет журналирования, что может привести к потере данных при сбоях системы.
Ext3 
- это развитие ext2, которое было выпущено в 2001 году. Оно добавило журналирование, что позволяет быстро восстановить файловую систему после сбоев. Ext3 также поддерживает файлы размером до 2 ТБ и объем раздела до 32 ТБ.
Ext4 
- это последняя версия файловой системы ext, которая была выпущена в 2008 году. Она добавила множество новых функций, таких как поддержка файлов размером до 16 ТБ и объем раздела до 1 экзабайта. Ext4 также поддерживает расширяемые атрибуты файлов, блокирование файлов на уровне ядра, быстрое создание файлов и многое другое.
	Все версии ext имеют схожую структуру. Файловая система ext состоит из блоков, которые делятся на группы. Каждая группа содержит таблицу дескрипторов блоков (inode table), которая хранит информацию о файлах и каталогах, а также данные блоков, которые содержат сами файлы и каталоги.
	Кроме того, файловая система ext использует дерево каталогов для организации файлов и каталогов. Каждый каталог может содержать подкаталоги и файлы, а также ссылки на другие файлы и каталоги.
	Файловые системы семейства ext обеспечивают высокую производительность и надежность, а также поддерживают множество функций, которые делают их идеальным выбором для большинства задач хранения данных в Linux.
XFS 
- это файловая система, разработанная компанией Silicon Graphics для использования в операционных системах UNIX. XFS поддерживает файлы размером до 8 ЭБ и объем раздела до 16 ЭБ. Она также обеспечивает высокую производительность при работе с большими файлами и каталогами. XFS использует журналирование для обеспечения надежности и быстрого восстановления после сбоев. Некоторые дистрибутивы Linux (например, Red Hat) предпочитают использовать XFS. Она рассчитана на работу с большими дисками. Скорость работы в таком случае выше, чем у ext4. Размер xfs может быть увеличен, но не может быть уменьшен.
Btrfs 
- это новая файловая система, которая была разработана для использования в Linux. Btrfs поддерживает файлы размером до 16 ЭБ и объем раздела до 16 ЭБ. Она также обеспечивает множество новых функций, таких как копирование на запись (Copy-on-Write), снимки (Snapshots), сжатие данных и дедупликацию (Deduplication). Btrfs не использует журналирование, но обеспечивает надежность за счет копирования на запись.
ISO9660 
- это стандартная файловая система для оптических носителей, таких как CD и DVD. ISO9660 поддерживает файлы размером до 2 ГБ и объем раздела до 2 ТБ. Она использует ограниченный набор символов для именования файлов и каталогов, что может вызывать проблемы совместимости с некоторыми операционными системами.
UDF 
- это универсальная файловая система, которая была разработана для использования на различных носителях, включая оптические диски, флеш-накопители и жесткие диски. UDF поддерживает файлы размером до 16 ЭБ и объем раздела до 2 ТБ. Она также обеспечивает надежность за счет журналирования и контроля целостности данных. UDF использует Unicode для именования файлов и каталогов, что обеспечивает совместимость с различными операционными системами.
Использование утилит для работы с файловыми системами
В Linux существует множество утилит для работы с файловыми системами. Некоторые из них:
fdisk 	- утилита для создания, удаления и изменения разделов на жестком диске. логический раздел (логический) можно создать.
mkfs 	- утилита для создания файловой системы на разделе.
fsck 	- утилита для проверки и восстановления файловой системы ext2, ext3 и ext4.
mount 	- утилита для монтирования файловых систем.
umount 	- утилита для отмонтирования файловых систем.
fsck 	- утилита для проверки и восстановления файловых систем.
blkid 	- утилита для определения типа и UUID файловой системы.
df 	- утилита для вывода информации о свободном месте на диске и использовании файловых систем.
du 	- утилита для вывода информации о размере каталогов и файлов.
lsblk 	- утилита для вывода информации о блочных устройствах, включая разделы и файловые системы. Нарисует дерево использования устройств. Нарисует дерево физических дисков.
Каждая из этих утилит имеет свои параметры и ключи, позволяющие настраивать их работу под конкретные задачи. Работа с файловыми системами в Linux может быть выполнена как в командной строке, так и с помощью графических интерфейсов, таких как GParted.

=========== UUID (Universally Unique Identifier) ============================================================================
	— это уникальный идентификатор, который присваивается каждому диску или разделу. 
	- физический IG устройства.
В Linux
Проверить правильность UUID в файле /etc/fstab с помощью команды blkid для каждого устройства. Если UUID неверен, нужно исправить записи в файле. Использовать live-образ системы для доступа к файлу /etc/fstab и редактирования UUID, если обновление initramfs не помогло.
ls -la /dev/disk/by-uuid/		- посмотреть UUID идентификаторы всех подключенных к системе дисков
Initramfs (initial RAM filesystem) 	— это небольшой корневой файловый системный образ, который загружается в оперативную память при запуске операционной системы Linux. При старте Linux загрузчик находит и загружает initramfs в память, а затем передаёт управление исполняемому файлу /init. Внутри initramfs содержится набор скриптов и программ, которые позволяют системе выполнить следующие действия:
	- загрузить модули ядра для оборудования;
	- настроить диск и файловые системы до монтирования основной файловой системы;
	- исполнить скрипт init, который выполняет дальнейшую инициализацию системы.


============ Настройка и контроль работы дисковых устройств (файл 4.2.)  + video ============================================
Форматирование физического диска, без создания LVM
sudo fdisk -l
Терминал распечатывает доступные устройства хранения с информацией о:
Model 			- Модель запоминающего устройства.
Disk 			- Имя и размер диска.
Sector size 		- логический и физический размер памяти. Не путать с доступным дисковым пространством.
Partition Table		- тип таблицы разделов (msdos, gpt, aix, amiga, bsd, dvh, mac, pc98, sun и loop).
Disk Flags 		- разделы с информацией о размере, типе, файловой системе и флагах.
Типы разделов могут быть:
Primary (Основной) 	- содержит файлы операционной системы. Можно создать только четыре основных раздела.
Extended (Расширенный) 	- особый тип раздела, в котором можно создать более четырех основных разделов.
Logical (Логический) 	- Раздел, созданный внутри расширенного раздела.
*-В нашем примере есть два устройства хранения - /dev/sda и /dev/sdb


Найдем жесткий диск, который мы хотим разбить на разделы. Обычно он будет иметь имя /dev/sdX, где X - это буква, соответствующая диску.

sudo fdisk /dev/sd2		- fdisk для выбранного диска. В интерактивном режиме мы можем создать два раздела. 
m				- команда для вызова справки

================ Создание физических томов (файл 4.5 + "управление логическими томами.txt")  + video ======================================================================
================ Создание групп томов (файл 4.6 + "управление логическими томами.txt")  + video ======================================================================
================ Создание логических томов + "управление логическими томами.txt" + video ==================================================================================
sudo lvcreate -l +100%FREE -n my_vol my_vg	- cоздадим логический раздел (виртуальный раздел) используя группу my_vg:
  Logical volume "my_vol" created
	-------------------------
sudo lvs					- отображает информацию о логических томах (LV), созданных с помощью LVM (Logical Volume Manager)
  LV     VG    Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  my_vol my_vg -wi-a----- 1.99g          
	-----------------------
lvdisplay					- отображает информацию о логических томах (LVs)
  --- Logical volume ---
  LV Path                /dev/my_vg/my_vol
  LV Name                my_vol
  VG Name                my_vg
  LV UUID                7l8Dgk-z4NY-RRzC-Gyb5-8luy-kVOZ-4s6iyL
  LV Write Access        read/write
  LV Creation host, time fhmo1o2bgbo5cmvtr29m, 2021-09-25 19:45:04 +0000
  LV Status              available
  # open                 0
  LV Size                1.99 GiB
  Current LE             510
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     256
  Block device           253:0
  ----------------------------
sudo mkfs.ext4 /dev/my_vg/my_vol		- создать файловую систему ext4, чтобы увеличивать и уменьшать её размер в будущем
	mke2fs 1.45.5 (07-Jan-2020)
	Creating filesystem with 522240 4k blocks and 130560 inodes
	Filesystem UUID: 12efe748-8763-4a1d-b674-2daf34015cef
	Superblock backups stored on blocks:
 	   32768, 98304, 163840, 229376, 294912
	Allocating group tables: done                            
	Writing inode tables: done                            
	Creating journal (8192 blocks): done
	Writing superblocks and filesystem accounting information: done 
	Диск доступен ещё так: /dev/mapper/my_vg-my_vol
	-----------------------------------------------

------------------ монтирование ------------------------------------------------------
sudo mount /dev/my_vg/my_vol /mnt/		- примонтировать его в директорию /mnt:
sudo df -h					- 
	Filesystem                Size  Used Avail Use% Mounted on
	udev                      966M     0  966M   0% /dev
	tmpfs                     199M  824K  198M   1% /run
	/dev/vda2                 9.8G  4.2G  5.2G  45% /
	tmpfs                     994M     0  994M   0% /dev/shm
	tmpfs                     5.0M     0  5.0M   0% /run/lock
	tmpfs                     994M     0  994M   0% /sys/fs/cgroup
	tmpfs                     199M     0  199M   0% /run/user/1000
	/dev/mapper/my_vg-my_vol  2.0G  6.0M  1.9G   1% /mnt 
	----------------------------------------------------
/etc/fstab					- команда mount монтирует диск только в рантайме. Чтобы диск примонтировался в директорию после перезагрузки хоста, необходимо прописать его в файл /etc/fstab. Сейчас он выглядит так:
	# /etc/fstab: static file system information.
	#
	# Use 'blkid' to print the universally unique identifier for a
	# device; this may be used with UUID= as a more robust way to name devices
	# that works even if disks are added and removed. See fstab(5).
	#
	# <file system> <mount point>   <type>  <options>       <dump>  <pass>
	/dev/mapper/astra--vg-root /               ext4    errors=remount-ro 0       1
	# /boot was on /dev/sda1 during installation
	UUID=2c8ff8d9-0555-410d-9e94-ffbe104d333a /boot           ext2    defaults        0       2
	/dev/mapper/astra--vg-swap_1 none            swap    sw              0       0
	-------------------------------------------------------------------------------
После рестарта монтируется только корневая директория.
Мы добавляем строчку:
	/dev/mapper/my_vg-my_vol                  /mnt            ext4    defaults 1 2 
sudo mount -a 					- примонтируем записи в fstab:
Отлично! Мы получили директорию, в которую можно записать 2 ГБ данных. Но в реальности это 2 раздела, которые могли бы быть на разных дисках.
sudo dd if=/dev/zero of=/mnt/payload bs=1M count=2048	- запишет в директорию произвольные данные:
	dd: error writing '/mnt/payload': No space left on device
	1954+0 records in
	1953+0 records out
	2048802816 bytes (2.0 GB, 1.9 GiB) copied, 230.615 s, 8.9 MB/s
sudo df -h
	/dev/mapper/my_vg-my_vol         2.0G  2.0G     0 100% /mnt
	Представьте, что вам и правда достались 2 разных диска. Без LVM пришлось бы создавать на каждом файловую систему командой mkfs.<fs_type> и примаунтить каждый в отдельную директорию, например, /mnt/1 и /mnt/2, но в таком случае диски нужно прописывать в /etc/fstab по UUID, а не по названию раздела, как в LVM. 
Для обращения с таким пронумерованными директориями существуют специальные файловые системы. Записывать просто в /mnt, конечно, легче. И расширять легко, давайте, кстати, это сделаем
Изменение размеров логических томов и файловых систем

----------------- Расширение раздела lvm ---------------------------------------------
Добавим ещё один раздел на физическом носителе таким образом, чтобы он занял всё оставшееся место на диске. Мы уже делали подобное с помощью fdisk, partprobe, lsblk.
Создадим на нём физический раздел lvm, как ранее — с помощью pvcreate.
sudo vgextend my_vg /dev/vdb3			- Добавим в виртуальную группу my_vg:
	Volume group "my_vg" successfully extended
	------------------------------------------
sudo vgs					- отображает информацию о группах томов (volume groups) в системе.
	VG    #PV #LV #SN Attr   VSize  VFree
	my_vg   3   1   0 wz--n- <3.99g <2.00g 
	--------------------------------------
sudo lvextend -l +100%FREE my_vg/my_vol		- увеличим наш логический диск lvm:
	Size of logical volume my_vg/my_vol changed from 1.99 GiB (510 extents) to <3.99 GiB (1021 extents).
	Logical volume my_vg/my_vol successfully resized.
	-------------------------------------------- 
sudo lsblk					- увидеть добавленный диск и общий список дисков на машине.
	NAME             MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
	vda              252:0    0  10G  0 disk
	├─vda1           252:1    0   1M  0 part
	└─vda2           252:2    0  10G  0 part /
	vdb              252:16   0   4G  0 disk
	├─vdb1           252:17   0   1G  0 part
	│ └─my_vg-my_vol 253:0    0   4G  0 lvm  /mnt
	├─vdb2           252:18   0   1G  0 part
	│ └─my_vg-my_vol 253:0    0   4G  0 lvm  /mnt
	└─vdb3           252:19   0   2G  0 part
	  └─my_vg-my_vol 253:0    0   4G  0 lvm  /mnt
	---------------------------------------------
sudo df -h
	Filesystem                Size  Used Avail Use% Mounted on
	/dev/mapper/my_vg-my_vol  2.0G  2.0G     0 100% /mnt 
	----------------------------------------------------
Как видите физически диск уже 4 ГБ, но система его по-прежнему видит как 2 ГБ, поэтому теперь необходимо расширить файловую систему:
sudo resize2fs /dev/my_vg/my_vol		- расширить файловую систему
	resize2fs 1.45.5 (07-Jan-2020)
	Filesystem at /dev/my_vg/my_vol is mounted on /mnt; on-line resizing required
	old_desc_blocks = 1, new_desc_blocks = 1
	The filesystem on /dev/my_vg/my_vol is now 1045504 (4k) blocks long.
	--------------------------------------------------------------------
sudo df -h
	Filesystem                Size  Used Avail Use% Mounted on
	/dev/mapper/my_vg-my_vol  3.9G  2.0G  1.8G  52% /mnt 
	----------------------------------------------------
Теперь у нас 3 диска, объединённых в 1. Для уменьшения раздела lvm действуем аналогично, но учитываем, что это опасная и нежелательная операция, потому что неверно указанные размеры нового логического диска lvm могут повредить ваши данные. Кроме того, уменьшение размера требует отключения файловой системы

---------------------- Отмонтируем раздел ----------------------------------------------------------------
Важно! Обратите внимание: в момент, когда мы отмонтируем раздел, не стоит находиться в его папке:
sudo df -h
	Filesystem                Size  Used Avail Use% Mounted on
	/dev/mapper/my_vg-my_vol  3.9G  2.0G  1.8G  52% /mnt

sudo umount /mnt 
sudo fsck.ext4 -f /dev/my_vg/my_vol		- Проверим файловую систему на ошибки и уменьшим логический диск lvm на 500 МБ:
	e2fsck 1.45.5 (07-Jan-2020)
	Pass 1: Checking inodes, blocks, and sizes
	Pass 2: Checking directory structure
	Pass 3: Checking directory connectivity
	Pass 4: Checking reference counts
	Pass 5: Checking group summary information
	/dev/my_vg/my_vol: 12/261120 files (0.0% non-contiguous), 526848/1045504 blocks

sudo lvreduce -L-500M /dev/my_vg/my_vol
	WARNING: Reducing active logical volume to 3.50 GiB.
	THIS MAY DESTROY YOUR DATA (filesystem etc.)
	Do you really want to reduce my_vg/my_vol? [y/n]: y
	  Size of logical volume my_vg/my_vol changed from <3.99 GiB (1021 extents) to 3.50 GiB (896 extents).
	  Logical volume my_vg/my_vol successfully resized.
	---------------------------------------------------
sudo resize2fs -f /dev/my_vg/my_vol
	resize2fs 1.45.5 (07-Jan-2020)
	Resizing the filesystem on /dev/my_vg/my_vol to 917504 (4k) blocks.
	The filesystem on /dev/my_vg/my_vol is now 917504 (4k) blocks long. 
	-------------------------------------------------------------------
Размер свободного места на логическом диске lvm должен быть точно больше размера уменьшаемого места, иначе часть данных потеряется.

sudo mount -a				- Монтируем снова
sudo df -h
	Filesystem                Size  Used Avail Use% Mounted on
	/dev/mapper/my_vg-my_vol  3.5G  2.0G  1.4G  60% /mnt 
	----------------------------------------------------
Размер уменьшился и наш файл payload на месте

Ещё трюки с LVM
pvmove -n my_vol /dev/sda1			- Перемещение раздела (при переносе со старого на новый диск)
lvcreate -s -n snap -L 5g my_vg/my_vol 		- Резервное копирование логического раздела/
lvconvert --merge my_vol/snap 			- Откат
lvremove /dev/my_vg/my_vol			- Удаление


================ Управление логическими томами LVM - Logical Volume Manager + "управление логическими томами.txt"(video) =====================================================
LVM	- Logical Volume Manager -  	это система управления логическими дисками на одном или нескольких физических дисках без переразметки физических дисков. LVM позволяет изменять размеры дисков, перемещать их без остановки процессов или размонтирования файловых систем. То есть LVM даёт возможность добавить ещё диск или расширить существующие LVM разделы на лету.
Преимущества использования логических дисков под управлением lvm перед разделами физического диска:
1.	Изменение размера: 		можно расширить или уменьшить раздел lvm без форматирования логических дисков.
2.	Расширяемость пространства: 	lvm позволяет увеличить доступное пространство, добавляя новые физические диски в пул lvm.
3.	Зеркалирование данных: 		lvm позволяет вести запись на несколько дисков одновременно, благодаря чему повышается производительность работы системы и появляется возможность дублировать данные на несколько логических дисков.
4.	Резервное копирование: 		lvm позволяет «заморозить» логический диск во время работы системы и сделать копию.
5.	Читаемые имена: 		логическим разделам можно давать любые понятные имена, что позволит легко понимать предназначение раздела.
LVM управляет тремя сущностями:
1.	Физический раздел		— Physical Volume (PV)	(может включать в себя несколько физических дисков) 
2.	Группа физических дисков 	— Volume Group (VG)
3.	Логический диск 		— Logical Volume (LV)
LV 		- Logical Volume. 	Раздел (логический том) не состоит из физического тома (PV)
PV 		- Phisical Volume	физический диск или раздел на диске. PV — базовый строительный блок LVM, используется для подготовки устройств к использованию в LVM.
Создание физических томов		(файл 4.5.) + video
Создание групп томов			(файл 4.6.) + video

lsblk 			- увидеть добавленный диск и общий список дисков на машине.
lsblk -f		- c флагом -f будут выведены также файловые системы на дисках и UUID
NAME                 FSTYPE      LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINT
sda
├─sda1               ext2              2c8ff8d9-0555-410d-9e94-ffbe104d333a    239,6M    44% /boot
├─sda2
└─sda5               LVM2_member       7hUFAY-a85S-pJGe-40bI-PSLu-PVut-DQ6mgv
  ├─astra--vg-root   ext4              982577a1-e3cc-4f0e-bec1-c108603a9e96     60,6G    16% /
  └─astra--vg-swap_1 swap              4d2467b2-30a4-4e45-852b-8f65f586c3a5                  [SWAP]
sdb			- новый диск — sdb. Он пока не размечен и ничем не занят.
NAME			— имя диска
FSTYPE			— тип файловой системы
LABEL			— метка, может содержать человекочитаемое описание диска
UUID			— физический ID устройства
FSAVAIL			— место на диске, доступное для файловой системы (обычно меньше физического размера диска)
FSUSE			— сколько места на диске занято
MOUNTPOINT		— точка монтирования

--------------------------------- разметим новый диск --------------------------------------------------------------
Есть два типа таблиц разметки: 
MBR (для устройств с BIOS) и 
GPT (для устройств с UEFI).(проходили во втором модуле). Разметка сохраняется в таблице разделов. Чтобы понимать какой вид разметки используется.
sudo fdisk -l		- вывод информации о дисках:
	Disk /dev/vda: 10 GiB, 10737418240 bytes, 20971520 sectors
	Units: sectors of 1 * 512 = 512 bytes
	Sector size (logical/physical): 512 bytes / 4096 bytes
	I/O size (minimum/optimal): 4096 bytes / 4096 bytes
	Disklabel type: gpt
	Disk identifier: 8E70400A-DD3F-443D-95C1-844A5A72302B
	Device     Start      End  Sectors Size Type
	/dev/vda1   2048     4095     2048   1M BIOS boot
	/dev/vda2   4096 20971486 20967391  10G Linux filesystem
	Disk /dev/vdb: 4 GiB, 4294967296 bytes, 8388608 sectors
	Units: sectors of 1 * 512 = 512 bytes
	Sector size (logical/physical): 512 bytes / 4096 bytes
	I/O size (minimum/optimal): 4096 bytes / 4096 bytes 

Как видно из выгрузки, /dev/vda размечен в GPT. Значит, у нас UEFI-система. 
Разметим и /dev/vdb: Для этого запустим для нового диска:
sudo fdisk /dev/vdb
	Welcome to fdisk (util-linux 2.34).
	Changes will remain in memory only, until you decide to write them.
	Be careful before using the write command.
	Device does not contain a recognized partition table.
	Created a new DOS disklabel with disk identifier 0x30cf485a.
	Command (m for help): 

g	создадим таблицу GPT (клавиша) :
	Created a new GPT disklabel (GUID: E83C9D88-AB63-3341-AB6F-2E7FAC0FC15D). 
	Создадим пару разделов размером 1 ГБ, а ещё 2 ГБ оставим неразмеченными:
	Command (m for help): 
n
	Partition number (1-128, default 1):
	First sector (2048-8388574, default 2048):
	Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-8388574, default 8388574): +1G
	Created a new partition 1 of type 'Linux filesystem' and of size 1 GiB.
	Command (m for help): 
n       
	Partition number (2-128, default 2):
	First sector (2099200-8388574, default 2099200):
	Last sector, +/-sectors or +/-size{K,M,G,T,P} (2099200-8388574, default 8388574): +1G
	Created a new partition 2 of type 'Linux filesystem' and of size 1 GiB.
	Command (m for help): 
w
	The partition table has been altered.
	Calling ioctl() to re-read partition table.
	Syncing disks. 
Теперь необходимо перезагрузить машину, чтобы таблица разделов тоже перезагрузилась.
sudo partprobe		- Важно! чтобы не перезагружать машину, мы воспользуемся утилитой partprobe, она перегружает таблицу без рестарта.
lsblk			- увидеть добавленный диск и общий список дисков на машине.
	NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
	vda    252:0    0  10G  0 disk
	├─vda1 252:1    0   1M  0 part
	└─vda2 252:2    0  10G  0 part /
	vdb    252:16   0   4G  0 disk
	├─vdb1 252:17   0   1G  0 part
	└─vdb2 252:18   0   1G  0 part
У нас 2 диска по 1 ГБ. Теперь можно создать файловую систему и примонтировать их. 

--------------------------
	ls -li				идентификаторы FS (inode) которыми оперирует Linux (имена файлов Linux не интересует)
	sudo fdisk 
	sudo parted		
	sudo mkfs			умеет форматировать диск в той или иной FS	
	sudo blkid
	lsusb
	lsblk
	EXT, Ext2, Ext3, Ext4

===========================================================================================================
---------------- Открыть диск хранения --------------------------------------------------------------------------
sudo fdisk /dev/sdb	- открыть диск хранения, который вы собираетесь разделить. Всегда указывайте запоминающее устройство. Если вы не укажете имя диска, он будет выбран случайным образом.

---------------- Создать таблицу разделов ----------------------------------------------------------------------
			- прежде чем разбивать диск, создайте таблицу разделов. Таблица разделов расположена в начале жесткого диска и хранит данные о размере и расположении каждого раздела.
Типы таблиц разделов: aix, amiga, bsd, dvh, gpt, mac, ms-dos, pc98, sun и loop.
mklabel [partition_table_type]		создать таблицу разделов
mklabel gpt				создать таблицу разделов gpt
sudo fdisk /dev/sdb	- открыть диск хранения, который вы собираетесь разделить. 
o			- создание новой, пустой таблицы разделов

--------------- проверьте таблицу -------------------------------------------------------------------------------
		Запустите команду print, чтобы просмотреть таблицу разделов. На выходе отображается информация об устройстве хранения.
Запустите команду help mkpart, чтобы получить дополнительную справку о том, как создать новый раздел.


--------------- Создайте раздел ---------------------------------------------------------------------------------
sudo lvcreate -l +100%FREE -n my_vol my_vg	- cоздать логический раздел (виртуальный раздел) используя группу my_vg:   Logical volume "my_vol" created.

sudo fdisk /dev/sdb
n						- создать новый раздел
						- Выберите номер раздела, набрав номер по умолчанию (2).
						- После этого вас попросят указать начальный и конечный сектор вашего жесткого диска. Лучше всего ввести в этом разделе номер по умолчанию (3622912).
				 Последний запрос связан с размером раздела. Вы можете выбрать несколько секторов или установить размер в мегабайтах или гигабайтах. Введите + 2 GB, чтобы установить размер раздела 2 ГБ.

Для этого введем последовательно:
n 				- новый раздел
p 				- тип раздела - основной
		1  - первичный
		0  - расширенный
		3  - свободно
e 				- тип раздела - расширенный (контейнер для логических разделов)

Теперь наш жесткий диск будет разделен на два раздела. В конце необходимо 
w				- сохранить изменения. После этого новая разметка диска будет сохранена.

sudo mkfs -t ext4 /dev/sda2	- отформатирование раздела в файловую систему ext4, и на этом разделе можно будет создавать и хранить файлы и папки
sudo mkpart primary ext4 1MB 1855MB	- создадим новый раздел размером 1854 Мбайт, используя файловую систему ext4. Назначенное начало диска должно быть 1 МБ, а конец диска - 1855 МБ. После этого запустите команду print, чтобы просмотреть информацию о вновь созданном разделе. Информация отображается в разделе Disk Flags:

-------------- запись на диск sudo fdisk ------------------------------------------------------------------------
w			- записать изменения на диск
print			- 
sudo fdisk -l		- 
/dev/sdb2 		- раздел создан

-------------- форматирование раздела ---------------------------------------------------------------------------
После создания раздела с помощью команды parted или fdisk отформатируйте его перед использованием.
sudo mkfs -t ext4 /dev/sdb1

-------------- Смонтировать раздел ------------------------------------------------------------------------------
Чтобы начать взаимодействие с диском, создайте точку монтирования (mount point) и смонтируйте к ней раздел.

sudo mkdir -p /mt/sdb1				- создание точки монтирования
sudo mount -t auto /dev/sbd1 /mt/sdb1		- монтирование раздела. Терминал не распечатывает вывод, если команды выполнены успешно.
df -hT						- убедиться, что раздел смонтирован. 
du -sh /

============ Монтирование файловых систем автоматически при загрузке компьютера (файл 4.3.)  + video ========================
lsblk
Параметры монтирования файловых систем
defaults 	- использует стандартные параметры монтирования.
noatime 	- не записывает время доступа к файлам, что уменьшает количество операций на диске и ускоряет работу системы.
ro 		- монтирует файловую систему в режиме только для чтения.
rw 		- монтирует файловую систему в режиме чтения и записи.
user 		- позволяет обычным пользователям монтировать и отмонтировать файловую систему.
noauto 		- не монтирует файловую систему автоматически при загрузке компьютера.
nouser 		- запрещает обычным пользователям монтировать и отмонтировать файловую систему.
exec 		- позволяет запускать исполняемые файлы с этой файловой системы.
noexec 		- запрещает запускать исполняемые файлы с этой файловой системы.

