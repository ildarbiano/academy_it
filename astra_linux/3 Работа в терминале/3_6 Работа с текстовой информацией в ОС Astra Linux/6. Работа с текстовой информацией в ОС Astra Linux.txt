Перенаправление стандартных потоков в файл или из файла
Перенаправление стандартных потоков между процессами
Команды для просмотра текстовых файлов в Linux
Команды-фильтры в Linux
Регулярные выражения
Потоковый фильтр grep
Потоковые редакторы sed и awk
Текстовый редактор vim
Другие текстовые редакторы
Практическое задание

стандартный поток вывода	1
стандартный поток ошибок	2

========== Перенаправление стандартных потоков в файл или из файла ===========
Перенаправление стандартных потоков в файл или из файла в Linux — это механизм, который позволяет перенаправлять вывод различных команд и приложений в файл, а также читать ввод из файла вместо терминала. Ниже мы рассмотрим основные примеры перенаправления в файл и из файла.

------ Перенаправление стандартного вывода в файл ------------------
>
>>
Чтобы записать вывод команды в файл, используйте символ > и укажите имя файла, куда вы хотите записать вывод.
Например:
$ echo "Hello World" > myfile.txt
Эта команда сохраняет строку "Hello World" в файле myfile.txt.
Вы можете дополнить файл, использовав символ >> вместо >:
$ echo "Hello Again" >> myfile.txt
Эта команда добавляет строку "Hello Again" в конец файла myfile.txt.

------ Перенаправление стандартного ввода из  ------------
Чтобы прочитать ввод из файла вместо терминала, вы можете использовать символ < и указать имя файла, откуда вы хотите считать ввод.
Например:
$ cat < myfile.txt
Эта команда читает содержимое файла myfile.txt и выводит его в терминал.
3.Комбинированное перенаправление
Вы можете комбинировать перенаправление стандартного ввода и вывода, используя символ |.
Например:
$ cat myfile.txt | grep "Hello"
Эта команда читает содержимое файла myfile.txt и фильтрует все строки, содержащие слово "Hello".

============= Перенаправление ошибок в файл ==================================
Вы можете перенаправить стандартную ошибку (stderr) в файл, используя символ 2> и указав имя файла.
Например:
$ ls /nonexistent 2> error.txt
Эта команда выполняет команду ls /nonexistent, но записывает любую ошибку в файл error.txt, оставляя стандартный вывод нетронутым.

============= Перенаправление вывода и ошибок в разные файлы ===================
Вы можете перенаправлять стандартный вывод и стандартную ошибку в разные файлы, используя символы > и 2> соответственно.
Например:
$ ls /nonexistent > output.txt 2> error.txt
Эта команда выполняет команду ls /nonexistent, записывает стандартный вывод в файл output.txt и любую ошибку в файл error.txt.

============= Перенаправление вывода и ошибок в один файл ========================
Вы можете перенаправить как стандартный вывод, так и стандартную ошибку в один файл, используя символ &> и указав имя файла.
Например:
$ ls /nonexistent &> output.txt
Эта команда выполняет команду ls /nonexistent и записывает как стандартный вывод, так и стандартную ошибку в файл output.txt.


============= Сортировка ========================
sort 1.txt	сортирует по алфавиту
sort -n 1.txt	сортирует по порядку


============= Перенаправление стандартных потоков между процессами ========================
комбинированный вывод 
&	разделитель команд (возможно $)
{command}&	упоминание после команды, mc&, запускает команду в фоновом режиме.
fg{command}	вывод программы из фонового режима.
&&	разделитель команд, только после отработки предыдущей
|	в случае выполнения предыдущей команды результат передался следущей команде "конвейер"
||	в случае не выполнения предыдущей команды результат передался следущей команде "конвейер"
;	передать следующей команды. результат не имеет значения. завершение строки.
Перенаправление стандартных потоков между процессами в Linux позволяет направлять вывод одного процесса на вход другого процесса, тем самым образуя цепочку процессов, работающих вместе.

Канал |
Используется для передачи стандартного вывода одного процесса на стандартный ввод другого процесса. 
Например, следующая команда передаёт вывод команды ls на вход команды grep, фильтруя вывод по шаблону "example":
$ ls | grep example

Канал >
Используется для перенаправления стандартного вывода одного процесса в файл. 
Например, следующая команда передаёт вывод команды ls в файл list.txt:
$ ls > list.txt

Канал <
Используется для перенаправления стандартного ввода процесса из файла. 
Например, следующая команда считывает ввод для команды grep из файла input.txt:
$ grep "example" < input.txt

Комбинированный канал >&
Используется для объединения стандартного вывода и стандартной ошибки одного процесса в одном файле. 
Например, следующая команда перенаправляет вывод и ошибку команды ls в файл list.txt:
$ ls > list.txt 2>&1

Разработка конвейеров
В Linux можно использовать множество команд, связанных в конвейер, чтобы обработать данные. 
Например, следующая команда использует команду tar, архивирующую файл, и затем передаёт вывод в ssh для копирования архива на удалённый сервер и распаковки:
$ tar cz /data | ssh remote_server 'tar xz -C /backup'
Эта команда архивирует содержимое каталога /data на локальном сервере и передаёт его через конвейер в ssh, который копирует архив на удалённый сервер и распаковывает его в каталог /backup.

Фоновый режим
Команды могут быть запущены в фоновом режиме, что означает, что они выполняются фоном, и вы можете выполнять другие задачи до тех пор, пока они не завершатся. Чтобы запустить команду в фоновом режиме, используйте символ & в конце команды. 
Например:
$ long_running_command &
Эта команда запускает long_running_command в фоновом режиме.


============= Команды для просмотра текстовых файлов в Linux ===============
В Linux есть множество команд для просмотра текстовых файлов.
cat
Используется для вывода содержимого текстовых файлов на экран. Например, чтобы просмотреть содержимое файла example.txt, просто введите:
$ cat example.txt

less
Используется для просмотра содержимого больших текстовых файлов. Кроме того, она позволяет пролистывать файлы вперёд и назад и искать текст. Например, чтобы просмотреть содержимое файла example.txt с помощью less, просто введите:
$ less example.txt

more
Похожа на less, но позволяет пролистывать файлы только вперёд. Например, чтобы просмотреть содержимое файла example.txt с помощью more, просто введите:
$ more example.txt

head
Используется для вывода первых нескольких строк файлов. По умолчанию head выводит первые 10 строк. Например, чтобы вывести первые 5 строк файла example.txt, просто введите:
$ head -n 5 example.txt		указано количество строк

tail
Используется для вывода последних нескольких строк файлов. По умолчанию tail выводит последние 10 строк. Например, чтобы вывести последние 5 строк файла example.txt, просто введите:
$ tail -n 5 example.txt		указано количество строк
Если хотите просмотреть поступающие логи в реальном времени:
$ tail -f /путь_до_лога


========== Команды-фильтры в Linux =========================
Команды-фильтры в Linux выполняются для обработки текстовых данных, часто используются в конвейере для фильтрации вывода команды или для преобразования данных в соответствии с определёнными критериями. Вот несколько примеров таких команд:
Потоковые редакторы, такие как sed и awk, являются мощными инструментами в системах Unix/Linux, которые могут быть использованы для манипулирования текстовыми файлами и потоками данных. В итоге, `sed` используется для базовых преобразований текста, таких как поиск и замена, а `awk` используется для более сложных задач обработки данных, таких как фильтрация и вычисления.

grep
Используется для поиска строк, содержащих заданный шаблон. 
Например, чтобы найти все строки в файле example.txt, содержащие слово "search", просто введите:
$ grep "search" /1/2/example.txt
$ grep "search" /1/2

sed
- означает «редактор потоков», является командной строковой утилитой, используемой для поиска и изменения текстовых файлов. Она выполняет базовые преобразования текста на входном потоке (файле или входных данных из конвейера) и выводит изменённый поток. Вот некоторые примеры использования sed:
Чтобы заменить первое вхождение строки на другую строку в файле:
Используется для преобразования текста. 
Например, чтобы заменить все вхождения слова "dog" на "cat" в файле example.txt и вывести результат в стандартный вывод, просто введите:
Чтобы заменить все вхождения строки на другую строку в файле:
sed 's/старый_текст/новый_текст/g' file.txt
sed 's/dog/cat/g' example.txt
sed -n  '5.10p' 1.txt
sed ''
Чтобы удалить строку, которая содержит определённую строку:
sed '/мой_текст/d' file.txt
Чтобы вставить новую строку после указанной строки:
sed '3a\текст_новой_строки' file.txt

awk
— это язык программирования, предназначенный для обработки текстовых файлов. Он читает входные файлы построчно и выполняет действия на основе шаблонов, которые появляются во входных данных.
Используется для обработки и фильтрации структурированных текстовых данных. 
Например, 
Чтобы найти второй столбец из файла example.csv, разделённого запятыми, используйте следующую команду:
$ awk -F, '{print $2}' example.csv
-F	-	
Чтобы вывести определённый столбец из файла:
awk '{print $1}' file.txt
Чтобы фильтровать вывод на основе определённого условия:
awk '$3 > 30' file.txt
Чтобы производить вычисления на столбце чисел:
awk '{sum += $2} END {print sum}' file.txt
Чтобы добавить новый столбец в файл:
awk '{print $1 "\t" $2 "\t" $3*2}' file.txt

\t	- метасимвол, 

sort
Используется для сортировки строк в файле. 
Например, чтобы отсортировать содержимое файла example.txt, просто введите:
$ sort example.txt

uniq
Используется для фильтрации повторяющихся строк. 
Например, чтобы вывести уникальные строки из файла example.txt, просто введите:
$ uniq example.txt


===================== Регулярные выражения ===========================================
https://regex101.com/
Регулярные выражения (regular expressions) в Linux используются для поиска и замены текста в файле или выводе команды в терминале. Они представляют собой шаблоны поиска, в которых используются специальные символы, предоставляющие множество вариантов поиска.

Основные символы регулярных выражений:
:	- функция
. 	— любой один символ, кроме новой строки
* 	— любое число символов, могут включать в себя и ноль символов
+ 	— одно или более повторений последнего символа
? 	— ноль или одно повторение последнего символа
()	- вводные аргументы. если требуется отменить какие-либо побочные эффекты, используйте (...).
[] 	— символы в квадратных скобках представляют собой любой из символов в скобках (например, [abc] ищет любой из символов a, b, или c)
{}	- раскрытие скобок. Результаты раскрытия каждой строки не сортируются; при раскрытии скобок сохраняется порядок слева направо. Если требуется, чтобы побочные эффекты списка команд повлияли на вашу текущую оболочку, используйте {...}
mkdir -p /home/admuser/data/{test1,test2,test3}		серия директорий, через перебор параметра
echo a{d,c,b}e						перебор параметров
ade ace abe
^ 	– начало строки
$ 	— конец строки
\s	- метасимвол , который указывает на пробел
Например, регулярное выражение t[a-z]st найдёт слова, начинающиеся с буквы t, за которыми следует любая буква от a до z, и заканчивающиеся на st.  Таким образом, выражение найдёт слова test, tast, и tust.
reg="^([A-Z|a-z|А-Я|а-я]{1,})\s{1,}([A-Z|a-z|А-Я|а-я]{1,25})\s{1,}([A-Z|a-z|А-Я|а-я]{1,25})$"	#----поиск трёх слов с пробелом [A-Z|a-z|А-Я|а-я]{1,})\s
if [[ $x =~ $reg ]]
then

Для применения регулярных выражений в Linux можно использовать команду grep. Например, для поиска всех строк в файле /var/log/syslog, начинающихся с буквы e, можно использовать следующую команду:
grep '^e' /var/log/syslog

Другой пример — поиск всех IP-адресов в выводе команды ifconfig с помощью регулярных выражений. 
Для этого нужно использовать следующую команду:
ifconfig | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"

В этом примере ifconfig выводится в стандартный поток ввода команды grep, которая использует флаг -o для вывода только найденных IP-адресов.
-o	- флаг, для вывода только найденного в "".
-E	- опция, которая указывает на использование расширенных регулярных выражений.

Регулярное выражение "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" ищет IP-адреса, состоящие из четырёх чисел, отделённых точками.
\b	- метасимвол , который указывает на границы слова (то есть на границы IP-адресов, чтобы не искать их части).

Таким образом, данная команда выведет все IP-адреса, указанные в выводе ifconfig.



================== Потоковый фильтр grep =================================
Команда grep (Global Regular Expression Print) используется для поиска строк в текстовых файлах, которые соответствуют заданному шаблону (регулярному выражению). Она часто используется в Unix-подобных ОС для фильтрации вывода других команд.

--------- Поиск строк, содержащих определённое слово в файле.
Допустим, вам нужно найти все строки в файле example.txt, содержащие слово "apple". Для этого можно использовать следующую команду:
grep "apple" example.txt
Эта команда выведет все строки, в которых встречается слово "apple", включая номера строк.

---------- Поиск строк в нескольких файлах.
Чтобы выполнить поиск по нескольким файлам, необходимо указать их имена через пробел:
grep "apple" example1.txt example2.txt
Эта команда выведет все строки, содержащие слово "apple", в файлах example1.txt и example2.txt.

---------- Игнорирование регистра символов.
По умолчанию grep учитывает регистр символов при поиске. Если необходимо производить поиск без учёта регистра, можно использовать опцию -i:
grep -i "apple" example.txt
Эта команда выведет все строки, в которых встречается слово "apple", без учёта регистра символов.

---------- Поиск строк, не содержащих заданный шаблон.
Чтобы найти строки, не содержащие заданный шаблон, можно использовать опцию -v:
grep -v "apple" example.txt
Эта команда выведет все строки, не содержащие слово "apple".

---------- Использование регулярных выражений.
Команда grep позволяет использовать регулярные выражения для более сложного поиска. Например, для поиска каждой строки, начинающейся с буквы "A", можно использовать следующее выражение:
grep '^A' example.txt
Эта команда найдет все строки, начинающиеся с буквы "A".

---------- Отображение номеров строк.
Чтобы отобразить номера строк, на которых были найдены совпадения, можно использовать опцию -n:
grep -n "apple" example.txt
Эта команда выведет все строки, содержащие слово "apple", вместе с номерами строк.

--------- Использование результата поиска в другой команде.
Результат поиска grep можно использовать в качестве входных данных для других команд. Например, для удаления всех строк, содержащих слово "apple", из файла example.txt можно использовать следующую команду:
grep -v "apple" example.txt > temp.txt && mv temp.txt example.txt

Данная команда выведет все строки, не содержащие слово "apple", в файл temp.txt, а затем заменит содержимое файла example.txt на содержимое файла temp.txt.


=============== 



